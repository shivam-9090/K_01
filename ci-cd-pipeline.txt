Big picture (system design view)
Developer
 → Git push
 → CI (build + test)
 → Artifact
 → CD (deploy)
 → Production


If a step fails, the pipeline stops. No hero fixes.

Core CI/CD components (one by one)
1. Source Control (starting point)

Git
GitHub

What happens

You push code

Webhook triggers the pipeline

Why it helps

Every change is tracked

Easy rollback

Collaboration without chaos

Without this, CI/CD cannot exist.

2. CI Tool (the automation brain)

GitHub Actions
GitLab CI
Jenkins

What it does

Listens for git events

Runs jobs in order

Jobs typically:

Install dependencies

Run tests

Run linters

Build artifacts

Why it helps

No “works on my machine”

Fail fast

Same checks for everyone

3. Build system (turn code into something runnable)

Examples:

npm build

mvn package

go build

Docker build

Output

Binary

Docker image

Build artifact

If it doesn’t build here, it should never reach prod.

4. Automated tests (your safety net)

Types:

Unit tests

Integration tests

API tests

Pipeline rule

Tests fail → deployment blocked

This saves you from:

Silent breakages

Releasing at night

Apology emails

5. Artifact repository (store built output)

Docker Hub
Amazon ECR
JFrog Artifactory

Why

Build once, deploy many times

Versioned, immutable artifacts

No rebuilding in production. Ever.

6. CD system (shipping machine)

Can be same as CI tool or separate.

What it does

Pulls artifact

Deploys to environment:

Dev

Staging

Production

Deployment strategies:

Rolling

Blue-green

Canary

Humans clicking “Upload build” is not deployment.

7. Infrastructure target (where it lands)

VM

Docker

Kubernetes

Cloud services

CI/CD doesn’t care where, as long as it’s scripted.

8. Secrets management (the quiet part)

API keys

DB passwords

Tokens

Stored in:

CI secrets vault

Cloud secret manager

Never inside repo. Never inside pipeline logs.

9. Monitoring & rollback (when things go wrong)

Pipeline should support:

Health checks

Auto rollback

Version tagging

If rollback is manual, you will panic.

How CI/CD makes your life easier

Blunt comparison.

Without CI/CD

Manual testing

Manual builds

Manual deploy

“It broke after merge”

Fear of pushing code

With CI/CD

Push code

Pipeline runs

Failures are immediate

Deployments are boring

Boring is good.

Minimal CI/CD pipeline (practical)

For a normal web app:

Push to main
 → Install deps
 → Run tests
 → Build Docker image
 → Push image to registry
 → Deploy to server


That’s enough. You don’t need 47 steps.

Where CI/CD fits in system design

CI/CD is not runtime architecture, but:

Enforces quality gates

Reduces human error

Makes scaling teams possible

No serious system design ignores it.

Hard truth

CI/CD doesn’t make bad code good.
It makes good habits unavoidable.